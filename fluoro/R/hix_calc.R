#' @title Calculate the Humification Index (HIX)
#'
#' @author Robert Lee, adapting original Matlab code by...
#'
#' @details Given a corrected EEM produced by the \code{f4.eem.correct} function, the function will
#' expand the EEM to a 1 nm resolution matrix using a spline interpolation called on first the emission
#' and then the exictation dimension. The HIX calculation is then performed according to the Ohno
#' method (2002). \cr
#' \cr
#' NOTE: the original Matlab code does not rely on a two step interploation, but performs a bivariate
#' spline intrpolation using the \code{interp2} function. As a result, the HIX values produced by
#' this code an the MatLab \code{F4CorrectFunII} code begin to differ after the fourth decimal.
#' Reconciling the two code bases to produce identical HIX values is an ongoing effort.
#'
#' @param \code{corr.eem} - A previosuly corrected EEM, generated by the \code{f4.eem.correct}
#' function. If the EEM isn't loaded, read it in with the \code{read.corr.eem} function.
#'
#' @return The calculated HIX value.
#'
#' @example
#'
#' @export
#'

hix.calc=function(corr.eem){
    require(pracma)


    # hix calcs require integration under the cuve at ex 254 from em435:480, and from em 300:345.
    # PROBLEM: correct eems have dimensions of em: 300-600 (increments 2nm)
    #                                          ex: 240-450 (increments 10 nm)
    # Need to expand the matrix to accomodate 1 nm increments. Orriginal matlab fucntion relies on
    # Spline interpolation into 1 nm increments for both dimensions

    # do spline in 1 dimentiosn, then another on top of that?



    #temp.matrix=corr.eem[rownames(corr.eem) %in% em,colnames(corr.eem) %in% ex]
    #
    #     temp=lapply(seq(length(corr.eem)), function(x) spline(x=as.numeric(corr.eem[x,]), y = as.numeric(colnames(corr.eem)), xout = ex))
    #
    #     temp=do.call(rbind, lapply(temp, "[[", "y"))
    #
    #     lapply(seq(length(temp[,1])), function(x) spline(x=as.numeric(temp[,x]), y = as.numeric(row.names(temp)), xout = em))
    #
    #     ##
    #
    #     y.list=data.frame(do.call(rbind, temp))$y
    #
    #     expanded.eem=data.frame(do.call(rbind, y.list))
    #     rownames(expanded.eem)=em
    #     colnames(expanded.eem)=ex.5
    #
    #
    #
    #     akima::interp(x = as.numeric(colnames(corr.eem)), y=NULL,
    #                   #y=as.numeric(row.names(corr.eem)),
    #                   z=as.matrix(corr.eem),
    #                   xo = seq(from=colnames(corr.eem)[1], to=colnames(corr.eem)[length(colnames(corr.eem))])
    #                     )

    # WAY 1 - Makes a liniear interpolation object
    # A=akima::bilinear.grid(y=colnames(corr.eem),
    #                        x=rownames(corr.eem),
    #                        z=as.matrix(corr.eem), xlim=c(300, 550), dx=1, ylim=c(240, 450), dy=1)
    #
    # expanded.eem=as.data.frame(A$z)
    # colnames(expanded.eem)=seq(from=240, to=450, by=1)
    # row.names(expanded.eem)= seq(from=300,  to=550, by=1)

    ### WAY 2
    temp.exp=lapply(seq(from=300, to=600, by=2),
                    function(u)
                        akima::aspline(x=as.numeric(colnames(corr.eem)),
                                       y = corr.eem[rownames(corr.eem)==u,],
                                       xout = seq(from=240, to = 450, by=1)
                                       )
                    )

    temp.exp=lapply(temp.exp, "[[", "y")


    temp.exp.2=data.frame(do.call(rbind, temp.exp))

    colnames(temp.exp.2)=seq(from=240, to=450, by=1)
    row.names(temp.exp.2)= seq(from=300,  to=600, by=2)

    rough.exp=lapply(seq(from=240, to=450),
           function(u)
               akima::aspline(x=as.numeric(rownames(temp.exp.2)),
                              y = temp.exp.2[,colnames(temp.exp.2)==u],
                              xout = seq(from=300, to = 600, by=1)
               )
    )
    temp.exp=lapply(rough.exp, "[[", "y")

    expanded.eem=data.frame(do.call(cbind, temp.exp))
    colnames(expanded.eem)=seq(from=240, to=450, by=1)
    row.names(expanded.eem)= seq(from=300,  to=600, by=1)



    #sum(expanded.eem[])

    # red=sum(expanded.eem[rownames(expanded.eem)>=435&480>=rownames(expanded.eem), colnames(expanded.eem)==254]) #Right var name?
    # blue=sum(expanded.eem[rownames(expanded.eem)>=300&345>=rownames(expanded.eem), colnames(expanded.eem)==254])

    redA=pracma::trapz(
        x=as.numeric(rownames(expanded.eem[rownames(expanded.eem)>=435&480>=rownames(expanded.eem),])),
        y=expanded.eem[rownames(expanded.eem)>=435&480>=rownames(expanded.eem), colnames(expanded.eem)==254]
    )

    blueA=pracma::trapz(
        x=as.numeric(rownames(expanded.eem[rownames(expanded.eem)>=300&345>=rownames(expanded.eem),])),
        y=expanded.eem[rownames(expanded.eem)>=300&345>=rownames(expanded.eem), colnames(expanded.eem)==254]
    )

    hix=round(redA/blueA, digits = 2)

    return(hix)
}
